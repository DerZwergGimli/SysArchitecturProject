# Vehicle Realtime Java (JamaicaVM) 

The emulated vehicle is realized with Java and compiled with "aicas JamaicaVM" to gain real-time behavior.

Note that: you will have to run this application as superuser/root to create threads that have a higher priority then normal threads.

## RT-System main components:

To get a brief overview the main parts of the application are:

1. Manager: This will start/stop/manage all threads and mange them. It checks the thread states to make sure all that should run are running.
2. TLidarDataCollection: This will collect the data from a LIDAR sensor and passes the data to a queue to analyze the data. Attached to this is a Overrun- and Miss-Hander. This thread will run periodically as a Realtime-Thread.
3. TCollisionAvoidance: This will read the data from a queue and performs some checks for obstacles and sends the data further to another queue. Attached to this is a Overrun- and Miss-Hander. This thread will run periodically as a Realtime-Thread.
4. TDatabaseWriter: This thread will collect the data and sends it to a database (in our case REDIS). This thread will run periodically as a Realtime-Thread.
5. TDatabaseReader: This thread will read from a database. This thread will run periodically as a Realtime-Thread. This thread is right now deactivated because there was at this time no use case!
6. osInterfaces: Those classes will provide access to the operating system to read system values like: CPU_temperature or network traffic.
7. gpioInterface.lidar: Those classes will provide access to the LIDAR sensor to read the values generated by the sensor.
8. redisInterface: This interface is for communicating with a REDIS database.
9. threads.hander: Those classes will be called if threads like TLidarDataCollection or TCollisionAvoidance are consuming to much time.
10. threads.interruptible: In here is the logic for all threads to make it easier to interrupt them all classes are implementing  "Interruptible".

More information you can find in the Java-Doc of this project.

## Overrun- and Miss-Handler

You can set the timing for those to handers for the classes

- LidarDataCollection
- CollisionAvoidance

There are three entries you can make:

1. periode: will define the time in ms when or how often the task will be performed (periodically)
2. cost: will define the time in ms how long the task should take but a cost overrun will only be logged as waring and the time will be increased by one ms. 
3. deadline: will define the time in ms how long the task should use cpu time. If the task takes longer than this amount of time it will be interrupted and the thread will be restarted. (Note that this can create a dead-loop).

![](/home/yannick/Desktop/PeriodicParamter.png)



## Collision Avoidance

A feature of our vehicle application is the collision avoidance by simple checking the distances with the allowed minimal distances defined in the configuration file.

It will generate 3 Types of stages the numbers in the brackets may vary:

-  objectDetected(0.9)
- ok(1.1)
- error(0.0)

![](/home/yannick/Desktop/collisionAvoidanceSections.png)

What the collision avoidance will do:

1. Read configuration settings
2. Take a section (for example frontRight).
3. Take relevant LIDAR data
4.  Check distances and count distances that are lager then the distance in the configuration file and count them to "OK" and count distances that are smaller than the distance in the configuration file and count them to "NOK".
5. Calculate the difference from "OK"/"NOK" = weighting (of this section).
6. Check if the weighting with the configuration.
7. Define state of this section: 
   1. ok: weighting.section > weighting.configuration
   2. objectDetected: weighting.section < weighting.configuration
   3. error: weighting.section = 0 or less than zero or any other error  
8.  Write final state with weighting to the section: objectDetected(0.9)
9.  Continue on with the other sections (step 2)
10. If all sections are checked. Send data to Queue and start again (at step 1). 

## Logging

This application provides logging abilities the configurations for this you can change in the "config_vehicle.properties" file which is generated when you launch the application for the fist time.

## Configuration-File

The application will generate a configuration file named: "config_vehicle.properties".

To change the behavior of the application you can edit this configuration file.

```c
#This is the configuration file for the Vehicle-Emulator

#Added a small delay for the banner (s)
banner.delay=0
console.clearScreen=false #This will clear the screan like if you call "clear" in a linux terminal window!
console.showStatusInConsole=false #This will print out the thread states

#Should threads be started when the application starts (true/false)
#Note that if you kill the manager the application will completely! You must have to execute the application on your platform again, by calling its binary file.
managementControl.managementThreadRunnable=true #This is the main appiclation should always be true
managementControl.collisionAvoidanceThreadRunnable=true #To enable the collion avoidance
managementControl.lidarDataCollection=true #To enable the data collection form a lidar sensor
managementControl.databaseReaderThreadRunnable=false #To read the data to a database
managementControl.databaseWriterThreadRunnable=true #To writre the collected data to the database
managementControl.exposeControlToDatabase=true #To controll the applucation from the databse (start/stop)

#CollisionAvoidance
collisonAvoidance.Front_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.FrontLeft_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.FrontRight_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.Left_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.Right_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.Back_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.BackLeft_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.BackRight_MinDistance=500 #Distance in mm for the obstecte avoidance / detection
collisonAvoidance.weighting=1.0 #difference of OK distances and NOK distances
collisonAvoidance.periode=250 # periode of the collsion avoidance thread
collisonAvoidance.cost=100 # cost of the collsion avoidance thread - not critical
collisonAvoidance.deadline=200 # deadline of the collsion avoidance thread - critila will restart the thread

#Redis-Config
redis.enable=true # To enable/disable the redis connection to the databse
redis.url=localhost # The url of the redis server
redis.port=32769 # Port of the redis server
redis.expireTime=1000 # Time in secounds when the redis values in the daatabse will be deleted

#Lidar-Config
lidar.enabled=true # To disable the whole lidar sensor if false then are random values generated (for tests)
lidar.initCommand=gpio mode 1 pwm # The command to initialize a gpio pin of a rpi for the lidar sensor
lidar.startRotationCommand=gpio pwm 1 250 # The command to set the rotation speed of the lidar motor
lidar.stopRotationCommand=gpio pwm 1 0 # To stop the rotation of the motor
lidar.scanCommand=/home/pi/vehicle/lidar/xv11test /dev/ttyAMA0 # The command to read the lidar values
lidar.periode=300 # periode of the lidar collection thread
lidar.cost=250 # cost of the lidar collection thread - not critical
lidar.deadline=275 # periode of the lidar collection thread - critila will restart the thread

#Logger-Config
logger.fileName=vehicleLog.log # the name and location of the log file.
logger.maxFileSize=100000 # the maximum file size of one logger file.
logger.maxNumberOfFiles=3 # the maximum file count 
logger.appendFiles=true # if the files should be appended or not
logger.debugLevel=ALL # the debug level (used: java.util.logging.Logger)

#NetworkInterface
networkInterface.enabled=true # to controll if the network interface should be read or not
networkInterface.name=wlp2s0 # the name if the network interface that should be read

#Top-Interface
topInterface.enabled=true # to controll if system infos form TOP should be read

#Sensors-Interface
sensorsInterface.enabled=true # to controll if system infos like cpu_temperature should be read

```

